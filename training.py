# -*- coding: utf-8 -*-
"""Copy of GameMaster.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EPo5gZAu3MwdEC4ylqebuC90elCmaEeD
"""

# ------------------------------
# 1. Install dependencies
# ------------------------------
#!pip install torch torchvision opencv-python numpy

# ------------------------------
# 2. Import Libraries
# ------------------------------
import os
import cv2
import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import Dataset, DataLoader
from torchvision import transforms
from torch.utils.data._utils.collate import default_collate

# ------------------------------
# 3. Dataset Class
# ------------------------------
class GameDataset(Dataset):
    def __init__(self, img_dir, action_file, transform=None):
        self.img_dir = img_dir
        self.actions = np.load(action_file, allow_pickle=True)
        self.transform = transform

        # Build key mapping dynamically from the loaded actions
        unique_keys = set()
        for key_list in self.actions:
            for k in key_list:
                unique_keys.add(str(k))
        unique_keys = sorted(list(unique_keys))
        # Add NOOP action if not present
        if "NOOP" not in unique_keys:
            unique_keys.append("NOOP")

        self.key_to_label = {k: i for i, k in enumerate(unique_keys)}
        self.label_to_key = {i: k for k, i in self.key_to_label.items()}
        self.num_actions = len(unique_keys)

        print(f"Detected {self.num_actions} actions with the following mapping:")
        for key, label in self.key_to_label.items():
            print(f"  {key}: {label}")

        # Convert all actions to labels
        self.labels = []
        for key_list in self.actions:
            key_list = [str(k) for k in key_list]  # normalize to strings
            if len(key_list) == 0:
                self.labels.append(self.key_to_label["NOOP"])
            else:
                # Assuming only the first action in the list is relevant
                self.labels.append(self.key_to_label.get(key_list[0], self.key_to_label["NOOP"])) # Use .get with default NOOP

        self.labels = np.array(self.labels)

    def __len__(self):
        return len(self.labels)

    def __getitem__(self, idx):
        img_path = os.path.join(self.img_dir, f"{idx}.png")
        image = cv2.imread(img_path)
        # Check if image loading was successful
        if image is None:
            print(f"Warning: Could not load image {img_path}. Skipping.")
            return None, None # Return None for image and label

        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        if self.transform:
            image = self.transform(image)
        label = self.labels[idx]
        return image, label

    # Add a collate_fn to handle None values if images are skipped
    def collate_fn(self, batch):
        batch = [(img, label) for img, label in batch if img is not None]
        if len(batch) == 0:
            return None, None
        return default_collate(batch)


# ------------------------------
# 4. Transform & Hyperparameters
# ------------------------------
transform = transforms.Compose([
    transforms.ToPILImage(),
    transforms.Resize((84, 84)),
    transforms.Grayscale(),   # optional
    transforms.ToTensor()
])

batch_size = 32
learning_rate = 1e-3
epochs = 20

# ------------------------------
# 5. Model
# ------------------------------
class GameNet(nn.Module):
    def __init__(self, num_actions):
        super().__init__()
        self.cnn = nn.Sequential(
            nn.Conv2d(1, 32, kernel_size=8, stride=4), nn.ReLU(),
            nn.Conv2d(32, 64, kernel_size=4, stride=2), nn.ReLU(),
            nn.Conv2d(64, 64, kernel_size=3, stride=1), nn.ReLU(),
            nn.Flatten()
        )
        self.fc = nn.Sequential(
            nn.Linear(64*7*7, 512), nn.ReLU(),
            nn.Linear(512, num_actions)
        )

    def forward(self, x):
        x = self.cnn(x)
        return self.fc(x)

# ------------------------------
# 6. Load Dataset
# ------------------------------


# Update these paths
img_dir = "dataset"
action_file = "dataset/actions.npy"
if not os.path.isdir(img_dir):
    raise FileNotFoundError()
dataset = GameDataset(img_dir, action_file, transform=transform)
dataloader = DataLoader(dataset, batch_size=batch_size, shuffle=True, collate_fn=dataset.collate_fn, num_workers=0)
# ------------------------------
# 7. Training Setup
# ------------------------------
device = "cuda" if torch.cuda.is_available() else "cpu"
model = GameNet(dataset.num_actions).to(device)
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=learning_rate)

# ------------------------------
# 8. Training Loop
# ------------------------------
for epoch in range(epochs):
    running_loss = 0.0
    for imgs, labels in dataloader:
        # Handle the case where a batch might be empty after filtering
        if imgs is None:
            continue

        imgs, labels = imgs.to(device), labels.to(device)
        outputs = model(imgs)
        loss = criterion(outputs, labels)
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
        running_loss += loss.item()
    print(f"Epoch {epoch+1}/{epochs} - Loss: {running_loss/len(dataloader):.4f}")

# ------------------------------
# 9. Save Model
# ------------------------------
torch.save(model.state_dict(), "model/GameMaster")
print("Model saved!")
